#!/usr/bin/env python3
import sys
import yaml
from pathlib import Path

ROOT = Path(__file__).resolve().parent.parent
SPEC = ROOT / "spec" / "messages.yml"

OUT_C = ROOT / "c" / "include" / "messages.h" 
OUT_CPP = ROOT / "cpp" / "include" / "messages.hpp"
OUT_PY = ROOT / "python" / "osusat_messaging" / "messages.py"


HEADER = """\
/**
 * Autogenerated by OSUSat Generator -- do not edit manually.
 * OSUSat Messaging Standard Command Table
 */
#ifndef OSUSAT_MESSAGES_H
#define OSUSAT_MESSAGES_H

#include <stdint.h>
"""

FOOTER = """\
#endif // OSUSAT_MESSAGES_H
"""

CPP_HEADER = """\
/**
 * Autogenerated by OSUSat Generator -- do not edit manually.
 * OSUSat Messaging Standard Command Table
 */
#ifndef OSUSAT_MESSAGES_HPP
#define OSUSAT_MESSAGES_HPP

#include <cstdint>

namespace OSUSat {
"""

CPP_FOOTER = """\
};

#endif // OSUSAT_MESSAGES_HPP
"""

PY_HEADER = '''"""
Autogenerated by OSUSat Generator -- do not edit manually.
OSUSat Messaging Standard Command Table
"""
'''

def gen_c_enum(name, mapping):
    """
        Generates a C enum object
    """

    lines = [f"typedef enum {name} {{"]

    for key, val in mapping.items():
        lines.append(f"    {name}_{key} = 0x{val:02X},")

    lines.append(f"}} {name};\n")

    return "\n".join(lines)

def gen_cpp_enum(name, mapping):
    """
        Generates a C++ scoped enum (enum class)
    """
    lines = [f"enum class {name} : uint8_t {{"]

    for key, val in mapping.items():
        lines.append(f"    {key} = 0x{val:02X},")

    lines.append("};\n")

    return "\n".join(lines)

def gen_py_enum(name, mapping):
    """
        Generates a Python enum object
    """

    lines = [f"class {name}:"]

    for key, val in mapping.items():
        lines.append(f"    {key} = 0x{val:02X}")
    lines.append("")

    return "\n".join(lines)

def assign_ids(spec):
    """
        Given a messaging spec, assign IDs to both common commands and 
        subsystem specific messages
    """

    common = {}
    next_id = 0x01

    for cmd in spec.get("common_commands", {}):
        common[cmd] = next_id
        next_id += 1

    # pad until 0x10 (reserved command space)
    while next_id <= 0x10:
        next_id += 1

    subsystems = {}

    for subsystem, commands in spec.get("subsystems", {}).items():
        subsystems[subsystem] = {}

        for cmd in commands:
            subsystems[subsystem][cmd] = next_id
            next_id += 1

    return common, subsystems

def main():
    with open(SPEC, "r") as f:
        spec = yaml.safe_load(f)

    common_cmds, subsys_cmds = assign_ids(spec)

    # -- Generate C Messages --

    c_out = [HEADER]

    c_out.append(gen_c_enum("OSUSatDestination", spec["destinations"]))
    c_out.append(gen_c_enum("OSUSatMessageType", spec["message_types"]))
    c_out.append(gen_c_enum("OSUSatCommonCommand", common_cmds))

    for subsystem, mapping in subsys_cmds.items():
        c_out.append(gen_c_enum(f"OSUSat{subsystem}Command", mapping))

    c_out.append(FOOTER)

    OUT_C.parent.mkdir(parents=True, exist_ok=True)
    OUT_C.write_text("\n".join(c_out))

    print(f"[+] Wrote {OUT_C}")

    # -- Generate CPP Messages --

    cpp_out = [CPP_HEADER]

    cpp_out.append(gen_cpp_enum("OSUSatDestination", spec["destinations"]))
    cpp_out.append(gen_cpp_enum("OSUSatMessageType", spec["message_types"]))
    cpp_out.append(gen_cpp_enum("OSUSatCommonCommand", common_cmds))

    for subsystem, mapping in subsys_cmds.items():
        cpp_out.append(gen_cpp_enum(f"OSUSat{subsystem}Command", mapping))

    cpp_out.append(CPP_FOOTER)

    OUT_CPP.parent.mkdir(parents=True, exist_ok=True)
    OUT_CPP.write_text("\n".join(cpp_out))

    print(f"[+] Wrote {OUT_CPP}")

    # -- Generate Python Messages --

    py_out = [PY_HEADER]

    py_out.append(gen_py_enum("Destination", spec["destinations"]))
    py_out.append(gen_py_enum("MessageType", spec["message_types"]))
    py_out.append(gen_py_enum("CommonCommand", common_cmds))

    for subsystem, mapping in subsys_cmds.items():
        py_out.append(gen_py_enum(f"{subsystem}Command", mapping))

    OUT_PY.parent.mkdir(parents=True, exist_ok=True)
    OUT_PY.write_text("\n".join(py_out))

    print(f"[+] Wrote {OUT_PY}")

if __name__ == "__main__":
    sys.exit(main())
